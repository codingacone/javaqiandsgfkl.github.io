<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java数据结构与算法</title>
      <link href="2021/01/03/java-shu-ju-jie-gou-yu-suan-fa/"/>
      <url>2021/01/03/java-shu-ju-jie-gou-yu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="一、循环队列"><a href="#一、循环队列" class="headerlink" title="一、循环队列"></a>一、循环队列</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>队列是一个<strong>有序列表</strong>，可以用<strong>数组</strong>或者<strong>链表</strong>来实现。</li><li>队列是先进先出的原则，就是和排队取票一样</li></ul><h3 id="模拟思路"><a href="#模拟思路" class="headerlink" title="模拟思路"></a>模拟思路</h3><ul><li><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量</p></li><li><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变，如图所示</p></li><li><p>front变量指向<strong>队首元素</strong>，初值为0</p></li><li><p>rear变量指向队尾元素的<strong>下一个元素</strong>，初值为0。规定空出一个位置</p></li><li><p>队列为空的判定条件：front == rear</p></li><li><p>队列为满的判定条件：(rear + 1) % maxSize == front</p></li><li><p>队列中有效元素的个数：(rear - front + maxSize) % maxSize</p></li><li><p>入队和出队时，都需要让标记<strong>对maxSize取模</strong></p><pre><code class="java">public class ArrayQueueDemo {    public static void main(String[] args) {    }    // 造一个循环队列的类    class CircleArray {        private int maxSize;// 数组长度        // 标记队列头        private int front;        // 标记队列尾        // rear 变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置.因为希望空出一个空间做为约定.        private int rear;        int[] arr;// 数组模拟循环队列        public CircleArray(int MaxSize) {            maxSize = MaxSize;            arr = new int[maxSize];        }        // 判断队列是否满        public boolean isFull() {            return (rear + 1) % maxSize == front;// 小算法        }        // 判断队列是否为空        public boolean isEmpty() {            return rear == front;        }        // 添加元素        public void addQueue(int n) {            // 判断队列是否满            if (isFull()) {                System.out.println("队列满，不能加入数据~");                return;            }            arr[rear] = n;            rear = (rear + 1) % maxSize;        }        // 获取队列的数据, 出队列        public int getQueue() {            // 判断是否为空            if (isEmpty()) {                // 通过抛出异常                throw new RuntimeException("队列空，不能取数据");            }            int v = arr[front];            front = (front + 1) % maxSize;            return v;        }        // 显示队列的所有数据        public void showQueue() {            if (isEmpty()) {                throw new RuntimeException("队列为空");            }            // 这是个循环队列有可能前面没值了，不可以把数组都遍历一遍            for (int i = front; i &lt; front + size(); i++) {                System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);            }        }        // 或得数组的有效个数        public int size() {            // rear = 2 front = 1 maxSize = 3            return (rear + maxSize - front) % maxSize;// 小算法        }        // 获得头数据        public int headQueue() {            if (isEmpty()) {                // 通过抛出异常                throw new RuntimeException("队列空");            }            return arr[front];        }    }}</code></pre></li></ul><h2 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h2><h3 id="1-单向链表"><a href="#1-单向链表" class="headerlink" title="1.单向链表"></a>1.单向链表</h3><h4 id="链表的介绍"><a href="#链表的介绍" class="headerlink" title="链表的介绍"></a>链表的介绍</h4><p>链表在内存中的存储</p><p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210103232924.png" alt="img"></p><p><strong>特点</strong></p><ul><li>链表是以节点的方式来存储,<strong>是链式存储</strong></li><li>每个节点包含 data 域 和 next 域。next域用来指向下一个节点</li><li>链表的各个节点不一定是连续存储的</li><li>链表分<strong>带头节点的链表</strong>和<strong>没有头节点的链表</strong>，根据实际的需求来确定</li></ul><p>带头结点的<strong>逻辑示意图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210103233738.png" alt="img"></p><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p><strong>创建（添加）</strong></p><ul><li><p>先创建一个Head头节点，表示单链表的头</p></li><li><p>后面我们每添加一个节点，就放在链表的最后</p><pre><code class="java">//在节点的最后添加public void add(StudentNode studentNode){    //我们的头结点不能动，因此要一个辅助节点temp    StudentNode temp = head.next;    while(true){        if(temp ==null){            break;//找到最后了我们就退出循环        }        //没有到最后就后移        temp = temp.next;    }    temp.next = studentNode;}</code></pre></li></ul><p><strong>遍历</strong></p><ul><li>通过一个辅助变量，来遍历整个链表</li></ul><p><strong>有序插入</strong></p><ul><li><p>先遍历链表，找到应该插入的位置</p></li><li><p>要插入的节点的next指向插入位置的后一个节点</p></li><li><p>插入位置的前一个节点的next指向要插入节点</p><ul><li>插入前要判断是否在队尾插入</li></ul></li></ul><p><strong>求链表的节点个数</strong></p><pre><code class="java">//我们要遍历所以要传一个头结点进来public static int getLinkedlength(StudentNode head){    //头结点不算    if(head.next == null){        return;    }    //辅助变量    StudentNode temp = head.nexd;    //定义计入的变量    StudentNode sum = 0;    while(temp! = null){        sum++;        temp = temp.next;    }    return sum;}</code></pre><p><strong>根据某个属性节点修改值</strong></p><ul><li>先遍历节点，找到修改的位置<ul><li>如果未找到修改节点，则不修改</li></ul></li></ul><p><strong>删除某个节点</strong></p><ul><li>先遍历节点，找到要删除节点的前一个节点</li><li>进行删除操作</li></ul><p><strong>求倒数第n个节点的信息</strong></p><ul><li>遍历链表，求出链表的<strong>有效长度</strong>length（不算头结点）</li><li>遍历链表到第length-n的节点</li></ul><pre><code class="java">public static StudentNode reciprocal(StudentNode head,int index){    //判断链表是否为空    if(head.next == null){        return null;    }    int size = getLinkedlength(head);//获得链表的个数    //头结点不能动创建一个辅助变量    StudentNode temp = head.next;    //校验传进来的值    if(index&lt;=0||index&gt;size){        return null;    }    //小算法size - index    for(int i = 0;i&lt;size - index;i++){        temp = temp.next;    }    return temp}</code></pre><p><strong>翻转链表</strong></p><p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210104232046.PNG" alt="捕获"></p><ul><li><p>创建一个新的头结点，作为新链表的头</p></li><li><p>从头遍历旧链表，将遍历到的节点插入新链表的头结点之后</p></li><li><p>注意需要用到</p><p>两个暂存节点</p><ul><li>一个用来保存正在遍历的节点</li><li>一个用来保存正在遍历节点的下一个节点</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210104233812.PNG" alt="1"></p><ul><li><p>遍历完后，进行出栈操作，同时打印出栈元素</p><pre><code class="java">public void reverseList(){    if (head.next ==null ||head.next.next=null){        return;    }    //辅助反转    StudentNode reverse = new StudentNode(0,"");    StudentNode cur = head.next;//辅助变量后面遍历用    StudentNode next = null;//用来保存cur的next节点    while (cur!=null){        next = cur.next;        cur.next = reverse.next;        reverse.next = cur;//新链表和cur连接        //后移        cur = next;    }    head.next = reverse.next;}</code></pre><p><strong>双指针的做法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210105000917.PNG" alt="捕获"></p><pre><code class="java">public class main15{    public ListNode ReverseLisst(ListNode head){        if(head == null){            return null;        }        ListNode frontNode = head;//第一个指针        ListNode removeNode = head.next;//第二个指针        while(removeNode!=null){            ListNode temp = removeNode.next;//辅助节点            removeNode.next; = frontNode;//反正            frontNode = removeNode;//后移            removeNode = temp;//后移    }        head.next = null;//不然死循环        return frontNode;}</code></pre></li></ul><pre><code class="java">import java.util.Stack;public class SingleLinkedListDemo {    public static void main(String[] args) {        // 创建节点        StudentNode hero1 = new StudentNode(1, "小王");        StudentNode hero2 = new StudentNode(4, "小花");        StudentNode hero3 = new StudentNode(7, "小星");        StudentNode hero4 = new StudentNode(6, "小龙");        // 创建链表        SingleLinkedList s1 = new SingleLinkedList();        // s1.add(hero1);        // s1.add(hero2);        // s1.add(hero3);        // s1.add(hero4);        s1.addByordera(hero3);        s1.addByordera(hero1);        s1.addByordera(hero2);        s1.addByordera(hero4);        System.out.println("原来链表的情况~~");        s1.list();        System.out.println("反转单链表~~");//        reversetList(s1.getHead());        reversePrint(s1.getHead());        s1.list();        /*         * s1.list(); System.out.println("修改后的链表情况~~"); StudentNode newStudentNode = new         * StudentNode(4, "小M"); s1.update(newStudentNode);         *          * s1.list(); s1.del(4); System.out.println("删除后的链表情况~~"); s1.list(); // 测试一下         * 求单链表中有效节点的个数 System.out.println("有效的节点个数=" + getLength(s1.getHead())); //         * 测试一下看看是否得到了倒数第K个节点 StudentNode res = findLastIndexNode(s1.getHead(), 1);         * System.out.println("res=" + res);         */    }    // 方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)    /**     *      * @param head 链表的头节点     * @return 返回的就是有效节点的个数     */    public static int getLength(StudentNode head) {        if (head.next == null) {            return 0;        }        int sum = 0;        // 辅助变量        StudentNode s2 = head.next;        while (s2 != null) {            sum++;            s2 = s2.next;        }        return sum;    }    // 查找单链表中的倒数第k个结点    // 思路    // 1. 编写一个方法，接收head节点，同时接收一个index    // 2. index 表示是倒数第index个节点    // 3. 先把链表从头到尾遍历，得到链表的总的长度 getLength    // 4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到    // 5. 如果找到了，则返回该节点，否则返回nulll    public static StudentNode findLastIndexNode(StudentNode head, int index) {        if (head.next == null) {            return null;        }        // 第一个遍历得到链表的长度(节点个数)        int size = getLength(head);        StudentNode temp = head.next;        // 第二次遍历 size-index 位置，就是我们倒数的第K个节点        // 先做一个index的校验        if (index &lt;= 0 || index &gt; size)            return null;        for (int i = 0; i &lt; size - index; i++) {            temp = temp.next;        }        return temp;    }    // 将单链表反转    public static void reversetList(StudentNode head) {        // 如果当前链表为空，或者只有一个节点，无需反转，直接返回        if (head.next == null || head.next.next == null) {            return;        }        // 定义一个辅助的指针(变量)，帮助我们遍历原来的链表        StudentNode temp = head.next;        StudentNode h1 = new StudentNode(0, "");        StudentNode t1 = null;// 指向当前节点[temp]的下一个节点        // 遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端        while (temp != null) {            t1 = temp.next;// 先暂时保存当前节点的下一个节点            temp.next = h1.next;// 将temp的下一个节点指向新的链表的最前端            h1.next = temp;// 将h1连接到新的链表上            temp = t1;// 让cur后移        }        // 将head.next 指向 reverseHead.next , 实现单链表的反转        head.next = h1.next;    }    // 可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果    public static void reversePrint(StudentNode head) {        if (head.next == null) {            return;        }        // 创建要给一个栈，将各个节点压入栈        Stack&lt;StudentNode&gt; s1 = new Stack&lt;StudentNode&gt;();        StudentNode temp = head.next;        // 将链表的所有节点压入栈        while (temp != null) {            s1.push(temp);            temp = temp.next;        }        // 将栈中的节点进行打印,pop 出栈        while (s1.size() &gt; 0) {            System.out.println(s1.pop()); // stack的特点是先进后出        }    }}class StudentNode {    public int id;    public String name;    public StudentNode next;// 指向下一个节点    public StudentNode(int id, String name) {        this.id = id;        this.name = name;    }    @Override    public String toString() {        return "StudentNode [id=" + id + ", name=" + name + "]";    }}class SingleLinkedList {    // 初始化头结点不存放数据；头结点不能动    private StudentNode head = new StudentNode(0, "");    public StudentNode getHead() {        return head;    }    public void setHead(StudentNode head) {        this.head = head;    }    // 思路我们找到next是null说明到最后了把next指向新节点就可以了    public void add(StudentNode studentNode) {        StudentNode temp = head;        while (true) {            if (temp.next == null) {                break;            }            // 如果没有找到最后, 将 temp 后移            temp = temp.next;        }        // 当退出时temp就在链表的最后我们连上即可        temp.next = studentNode;    }    public void addByordera(StudentNode studentNode) {        StudentNode temp = head;        boolean flag = false;// 标记        while (true) {            if (temp.next == null) {                break;            }            if (temp.next.id &gt; studentNode.id) {                break;            } else if (temp.next.id == studentNode.id) {                flag = true;// 说明希望添加的的编号已然存在                break;            }            temp = temp.next;        }        if (flag) {            System.out.printf("准备插入的英雄的编号 %d 已经存在了, 不能加入\n", studentNode.id);        } else {            studentNode.next = temp.next;            temp.next = studentNode;        }    }    // 修改节点的信息, 根据id编号来修改，即id编号不能改.    public void update(StudentNode newStudentNode) {        if (head.next == null) {            System.out.println("没有元素");        }        // 找到需要修改的节点, 根据no编号        // 定义一个辅助变量        StudentNode temp = head.next;        boolean flag = false;// 标记是否找到        while (true) {            if (temp == null) {                break;// 已经遍历完链表            }            if (temp.id == newStudentNode.id) {                flag = true;                break;            }            temp = temp.next;        }        // 根据flag 判断是否找到要修改的节点        if (flag) {            temp.name = newStudentNode.name;        } else {// 没有找到            System.out.printf("没有找到 编号 %d 的节点，不能修改\n", newStudentNode.id);        }    }    // 删除节点    // 思路    // 1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点    // 2. 说明我们在比较时，是temp.next.id 和 需要删除的节点的id比较    public void del(int n) {        StudentNode temp = head.next;        boolean flag = false;// 标记是否找到        while (true) {            if (temp.next == null) {                break;// 遍历到最后了            }            if (temp.next.id == n) {                flag = true;                break;            }            temp = temp.next;        }        if (flag) {            temp.next = temp.next.next;        } else {            System.out.printf("要删除的 %d 节点不存在\n", n);        }    }    // 显示链表    public void list() {        // 判断链表是否为空        if (head.next == null) {            return;        }        StudentNode temp = head.next;        while (true) {            if (temp == null) {                break;            }            // 输出节点信息            System.out.println(temp);            // 要后移            temp = temp.next;        }    }}</code></pre><h3 id="2-双向链表"><a href="#2-双向链表" class="headerlink" title="2.双向链表"></a>2.双向链表</h3><h4 id="分析双向链表的遍历，添加，修改，删除的操作思路及代码"><a href="#分析双向链表的遍历，添加，修改，删除的操作思路及代码" class="headerlink" title="分析双向链表的遍历，添加，修改，删除的操作思路及代码"></a>分析双向链表的遍历，添加，修改，删除的操作思路及代码</h4><p><strong>对比单向链表多了往回指的一个pre指针</strong></p><ol><li><p>遍历方法和单向链表一样，只是可以向前，也可以向后查找。</p><pre><code class="JAVA">public void list() {        // 判断链表是否为空        if (head.next == null) {            return;        }        HeroNode temp = head.next;        while (true) {            if (temp.next == null) {                break;            }            // 输出节点的信息            System.out.println(temp);            temp = temp.next;        }    }</code></pre></li></ol><ol start="2"><li><p>添加（默认添加到双向链表的最后）：</p><ul><li><p>先找到双向链表的最后这个节点</p></li><li><p>temp.next=newHeroNode；</p></li><li><p>newHeroNode.pre=temp；</p><pre><code class="java">public void add(HeroNode heroNode) {        HeroNode temp = head.next;        // 遍历到最后然后添加        while (true) {            if (temp.next == null) {                break;            }            temp = temp.next;        }        temp.next = heroNode;        heroNode.pre = temp;    }</code></pre></li></ul></li></ol><ol start="3"><li><p>修改思路和原来的单向链表一样。</p></li><li><p>删除：</p><ul><li>因为是双向链表，因此，我们可以实现自我删除某个节点</li><li>直接找到要删除的这个节点，比如temp</li><li>temp.pre.next=temp.next；</li><li>temp.next.pre=temp.pre；</li></ul></li></ol><pre><code class="java">public void del(int id) {        if (head.next == null) {            return;        }        HeroNode temp = head.next;        boolean falg = false;        while (true) {            if (temp.next == null) {                break;            }            if (temp.id == id) {                falg = true;            }            temp = temp.next;        }        if (falg) {            temp.pre.next = temp.next;            if (temp.next != null) {                temp.next.pre = temp.pre;            }        } else {            System.out.printf("要删除的 %d 节点不存在\n", id);        }    }</code></pre><h3 id="3-循环队列和约瑟夫问题"><a href="#3-循环队列和约瑟夫问题" class="headerlink" title="3.循环队列和约瑟夫问题"></a>3.循环队列和约瑟夫问题</h3><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210108001258" alt="PNG"></p><p><strong>添加节点</strong></p><p>循环队列只要把最后一个节点指向最前面即可</p><pre><code class="java">class CircleSing {    private Boy first = new Boy(-1);    //nums一共多少个节点    public void add(int nums) {        if (nums &lt; 1) {            return;        }        //辅助变量        Boy curBoy = null;        for (int i = 1; i &lt;= nums; i++) {            // 根据编号创建            Boy boy = new Boy(i);            //第一个节点添加方式和其他节点不一样            if (i == 1) {                //first 不能动用来最后一个节点指回到头结点                first = boy;                first.setNext(first);                curBoy = first;            } else {                curBoy.setNext(boy);                boy.setNext(first);                curBoy = boy;            }        }    }</code></pre><p><strong>遍历节点</strong></p><p>最后节点指向最前面一个节点说明遍历完成</p><pre><code class="java">public void ShowBoy() {        if(first ==null) {            return;        }        Boy cur = first;        while(true) {            System.out.println(cur.getId());            if(cur.getNext()==first) {                break;            }            cur = cur.getNext();        }    }</code></pre><h4 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>约瑟夫问题（约瑟夫环、丢手绢问题）为：设编号为1，2，…n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>用一个不带头结点的循环链表来处理Josephu问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</p><h5 id="出圈的思路及代码"><a href="#出圈的思路及代码" class="headerlink" title="出圈的思路及代码"></a>出圈的思路及代码</h5><p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210108001536.png" alt="img"></p><pre><code class="java">/**     *      * @param start 表示从第几个小孩开始     * @param count 表示数几下     * @param nums  有几个小孩     */    public void countBoy(int start, int count, int nums) {        //        if (first == null || start &lt; 1 || nums &gt; nums) {            return;        }        //辅助变量        Boy helper = first;        while (true) {            if (helper.getNext() == null) {                break;            }            helper = helper.getNext();//让helper指向队列的最后节点位置        }        for (int i = 0; i &lt; start - 1; i++) {            first = first.getNext();//first找到要游戏开始的位置            helper = helper.getNext();            //从第几个孩子开始游戏        }        while (true) {            if (helper == first) {                break;            }            for (int i = 0; i &lt; count - 1; i++) {                first = first.getNext();                helper = helper.getNext();                //找到要退出孩子的节点            }            System.out.print(first.getId());            first = first.getNext();//first变成退出孩子节点得下一个节点            helper.setNext(first);//helper指向新的first节点        }        System.out.print(first.getId());</code></pre><h2 id="三、栈"><a href="#三、栈" class="headerlink" title="三、栈"></a>三、栈</h2><ol><li>栈的英文为(<strong>stack</strong>)</li><li>栈是一个<strong>先入后出</strong>(FILO-First In Last Out)的有序列表。</li><li>栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为<strong>变化的一端，称为栈顶</strong>(Top)，另一端为<strong>固定的一端，称为栈底</strong>(Bottom)。</li><li>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除。</li><li>栈的插入操作(<strong>push</strong>)，称压栈、入栈。类似子弹入弹夹。<br>栈的删除操作(<strong>pop</strong>)，叫作出栈，也有的叫作弹栈。如同弹夹中的子弹出夹。</li></ol><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><strong>顺序存储</strong><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210110173846.png" alt="img"></p><p><strong>链式存储</strong></p><p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210110173926.png" alt="img"></p><h3 id="数组模拟栈"><a href="#数组模拟栈" class="headerlink" title="数组模拟栈"></a>数组模拟栈</h3><pre><code class="java">public class ArrayStack {    public static void main(String[] args) {    }}class Stack3 {    private int[] stack;    private int top = -1;    private int maxsize;    public Stack3(int[] stack1, int top, int maxsize) {        stack = new int[maxsize];        this.top = top;    }    public boolean isFull() {        return top == maxsize - 1;    }    public boolean isEmpty() {        return top == -1;    }    public void push(int value) {        if (isFull()) {            return;        }        stack[++top] = value;    }    public int pop() {        if (isEmpty()) {            return -1;        }        return stack[top--];    }    // 遍历    public void list() {        if (isEmpty()) {            return;        }        for (int i = top; i &gt;= 0; i--) {            System.out.println(stack[i]);        }    }</code></pre><h3 id="中缀表达式转后缀"><a href="#中缀表达式转后缀" class="headerlink" title="中缀表达式转后缀"></a>中缀表达式转后缀</h3><p><strong>思路</strong></p><ol><li>初始化：运算符栈stack和动态数组(ArrayList) list；</li><li>从左至右扫描中缀表达式；</li><li>遇到操作数时，将其添加到list中；</li><li>遇到运算符时，比较其与stack栈顶运算符的优先级：<ul><li>如果stack为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</li><li>如果优先级比栈顶运算符的高，也将运算符压入stack；</li><li>如果优先级比栈顶运算符的低，将stack栈中的<strong>所有运算符</strong>弹出并追加到list中。</li></ul></li><li>遇到括号时：<ul><li>如果是左括号“(”，则直接压入stack;</li><li>如果是右括号“)”，则依次弹出stack栈顶的运算符，并追加到list中，直到遇到左括号为止，此时将这一对括号丢弃。</li></ul></li><li>从左至右扫描中缀表达式结束后，将stack中剩余的运算符依次追加到list中。</li></ol><pre><code class="java">    // 方法：将 中缀表达式转成对应的List    // s="1+((2+3)×4)-5";    public static List&lt;String&gt; toInfixExpressionList(String s) {        List&lt;String&gt; l1 = new ArrayList&lt;String&gt;();        int index = 0;// 遍历指针        String p = "";// 多位数用到的拼接        char c;// 遍历的字符都放进去        do {            if ((c = s.charAt(index)) &lt; 48 || (c = s.charAt(index)) &gt; 57) {                l1.add("" + c);                index++;            } else {                while (index &lt; s.length() &amp;&amp; (c = s.charAt(index)) &gt;= 48 &amp;&amp; (c = s.charAt(index)) &lt;= 57) {                    p = "";                    p += c;                    index++;                }                l1.add(p);            }        } while (index &lt; s.length());        return l1;    }    // 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–]    // 方法：将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List    public static List&lt;String&gt; parseSuffixExpreesionList(List&lt;String&gt; l1) {        // 定义两个栈        Stack&lt;String&gt; s1 = new Stack&lt;String&gt;(); // 符号栈        // 说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出        // 因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; s2        // Stack&lt;String&gt; s2 = new Stack&lt;String&gt;(); // 储存中间结果的栈s2        List&lt;String&gt; s2 = new ArrayList&lt;String&gt;(); // 储存中间结果的Lists2        for (String item : l1) {            if (item.matches("\\d+")) {                s2.add(item);            } else if (item.equals("(")) {                s1.add(item);            } else if (item.equals(")")) {                while (!s1.peek().equals("(")) {                    s2.add(s1.pop());                }                s1.pop();            } else {                while (s1.size() != 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item)) {                    s2.add(s1.pop());                }                s1.push(item);            }        }        while (s1.size() != 0) {            s2.add(s1.pop());        }        return s2;    }}class Operation {    private int add = 1;    private int sub = 1;    private int mul = 2;    private int div = 2;    public static int getValue(String operation) {        int result = 0;        switch (operation) {        case "+":            result = 1;            break;        case "-":            result = 1;            break;        case "*":            result = 2;            break;        case "/":            result = 2;            break;        default:            System.out.println("不存在该运算符" + operation);            break;        }        return result;    }</code></pre><h2 id="四、递归"><a href="#四、递归" class="headerlink" title="四、递归"></a>四、递归</h2><p><strong>递归就是简单的说， 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。</strong></p><p>打印问题：</p><pre><code class="java">public static void test(int n) {    if (n &gt; 2) {        test(n - 1);    }    System.out.println("n=" + n);}</code></pre><h3 id="递归使用的规则"><a href="#递归使用的规则" class="headerlink" title="递归使用的规则"></a>递归使用的规则</h3><ul><li><p>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</p></li><li><p>方法的局部变量是独立的，不会相互影响</p></li><li><p>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据</p></li><li><p>递归<strong>必须向退出递归的条件逼近</strong>，否则就是无限递归,出现StackOverflowError异常</p></li><li><p>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</p></li></ul><h3 id="递归和回溯的区别"><a href="#递归和回溯的区别" class="headerlink" title="递归和回溯的区别"></a>递归和回溯的区别</h3><p><strong>递归是一种算法结构</strong>。递归会出现在子程序中，形式上表现为直接或间接的自己调用自己。</p><p><strong>回溯是一种算法思想</strong>。它是用递归实现的。回溯的过程类似于穷举法，但回溯有“剪枝”功能，即自我判断过程。例如有求和问题，给定有 7 个元素的组合 [1, 2, 3, 4, 5, 6, 7]，求加和为 7 的子集。累加计算中，选择 1+2+3+4 时，判断得到结果为 10 大于 7，那么后面的 5, 6, 7 就没有必要计算了。这种方法属于搜索过程中的优化，即“剪枝”功能。</p><p>用一个比较通俗的说法来解释递归和回溯：<br>我们在路上走着，前面是一个多岔路口，因为我们并不知道应该走哪条路，所以我们需要尝试。<strong>尝试的过程就是一个函数。</strong><br>我们选择了一个方向，后来发现又有一个多岔路口，这时候又需要进行一次选择。所以<strong>我们需要在上一次尝试结果的基础上，再做一次尝试</strong>，即<strong>在函数内部再调用一次函数</strong>，这就是<strong>递归</strong>的过程。<br>这样重复了若干次之后，发现<strong>这次选择的这条路走不通，这时候我们知道我们上一个路口选错了，所以我们要回到上一个路口重新选择其他路</strong>，这就是<strong>回溯</strong>的思想。</p><h3 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h3><p><a href="https://cdn.jsdelivr.net/gh/839777408/tupian/blog/20200729111731.png"><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210110175513.png" alt="img"></a></p><pre><code class="java">public class MiGong {    public static void main(String[] args) {        int[][] arr = new int[8][7];        for (int i = 0; i &lt; 7; i++) {            arr[0][i] = 1;            arr[7][i] = 1;        }        for (int i = 0; i &lt; 8; i++) {            arr[i][0] = 1;            arr[i][6] = 1;        }        arr[3][1] = 1;        arr[3][2] = 1;        for (int arr1[] : arr) {            for (int a : arr1) {                System.out.print(a + "  ");            }            System.out.println("");        }        setWay(arr, 1, 1);        System.out.println("小球走过，并标识过的地图的情况：");        for (int i = 0; i &lt; 8; i++) {            for (int j = 0; j &lt; 7; j++) {                System.out.print(arr[i][j] + "  ");            }            System.out.println("");        }    }    // 使用递归回溯来给小球找路    // 说明    // 1. map 表示地图    // 2. i,j 表示从地图的哪个位置开始出发 (1,1)    // 3. 如果小球能到 map[6][5] 位置，则说明通路找到.    // 4. 约定： 当map[i][j] 为 0 表示该点没有走过；为 1 表示墙 ； 2 表示走过，是通路 ； 3 表示该点已经走过，但是走不通    // 5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯    public static boolean setWay(int[][] arr, int i, int j) {        if (arr[6][5] == 2) {            return true;        } else {            if (arr[i][j] == 0) {                arr[i][j] = 2;                if (setWay(arr, i++, j)) {                    return true;                } else if (setWay(arr, i--, j)) {                    return true;                } else if (setWay(arr, i, j++)) {                    return true;                } else if (setWay(arr, i, j--)) {                    return true;                } else {                    arr[i][j] = 3;                    return false;                }            } else {                return false;            }        }    }}</code></pre><p><strong>结果</strong></p><pre><code class="java">1  1  1  1  1  1  1  1  0  0  0  0  0  1  1  0  0  0  0  0  1  1  1  1  0  0  0  1  1  0  0  0  0  0  1  1  0  0  0  0  0  1  1  0  0  0  0  0  1  1  1  1  1  1  1  1  小球走过，并标识过的地图的情况：1  1  1  1  1  1  1  1  2  0  0  0  0  1  1  2  2  2  0  0  1  1  1  1  2  0  0  1  1  0  0  2  0  0  1  1  0  0  2  0  0  1  1  0  0  2  2  2  1  1  1  1  1  1  1  1  </code></pre><h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><p><strong>说明</strong></p><p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p><ul><li>第一个皇后先放第一行第一列</li><li>第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</li><li>继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，就算是找到了一个正确解</li><li>当得到一个正确解时，栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</li><li>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤</li></ul><pre><code class="java">public class Queue8 {    int max = 8;    int[] arr = new int[max];    static int count;    static int judgecount;    public static void main(String[] args) {        // 测试一把 ， 8皇后是否正确        Queue8 queue8 = new Queue8();        queue8.check(0);        System.out.printf("一共有%d解法", count);        System.out.printf("一共判断冲突的次数%d次", judgecount); // 1.5w    }    public boolean judge(int a) {// a表示第几个皇后        judgecount++;        for (int i = 0; i &lt; a; i++) {//传进来的数和之前进来的所有数都判断            // 当arr[i] == arr[a]时，表示两个皇后处于同一列；            // 当Math.abs(a-i) == Math.abs(arr[a]-arr[i])时，            // 表示两条直角边相等，斜率为1，等腰直角三角形，两个皇后处于对角线，            if (arr[i] == arr[a] || Math.abs(a - i) == Math.abs(arr[a] - arr[i])) {                return false;            }        }        return true;    }    public void check(int a) {        if (a == max) {            print();            count++;            return;        }        for (int i = 0; i &lt; max; i++) {//每次都进来都从a-1行的0列开始            arr[a] = i;            if (judge(a)) {                check(a + 1);            }        }    }    public void print() {        for (int s : arr) {            System.out.print(s);        }        System.out.println();    }}</code></pre><p><strong>结果</strong></p><pre><code class="java">一共有92解法一共判断冲突的次数15720次</code></pre><h2 id="五、排序算法"><a href="#五、排序算法" class="headerlink" title="五、排序算法"></a>五、排序算法</h2><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p><strong>荷兰国旗问题</strong></p><p>给定一个数组arr，和一个数num，请把小于num的数放在数组的<br>左边，等于num的数放在数组的中间，大于num的数放在数组的<br>右边。</p><pre><code class="java">public int []partition(int[]arr,int l,int r,int num){    less = l-1;//小于区域    more = r+1;//大于区域    while(l&lt;r){        if(arr[l]&lt;num){            swap(arr,++less,l++);        }        else if(arr[l]&gt;num){            swap(arr,--more,l);        }        else{//arr[l] = nums            i++;        }        return new arr[]{less-1,more+1};//数组里是等于区的左右下标    }}public static void swap(int[] arr, int l, int r) {        int temp = arr[l];        arr[l] = arr[r];        arr[r] = temp;    }</code></pre><ul><li>快排就是在荷兰国旗代码上递归</li></ul><pre><code class="java">public class QuickSort {    public static void main(String[] args) {        int[] arr = { -9, 78, 0, 23, -567, 70, -1, 900, 4561 };        qucik(arr, 0, arr.length - 1);        for (int s : arr) {            System.out.print(s + " ");        }    }    public static void qucik(int[] s1, int l, int r) {        if (l &lt; r) {            swap(s1, l + (int) (Math.random() * (r - l + 1)), r);//随机在数组中选一个数和数组最后一个数交换            int[] p = partition(s1, l, r);            qucik(s1, l, p[0] - 1);            qucik(s1, p[1] + 1, r);        }    }    public static int[] partition(int[] s1, int l, int r) {        int less = l - 1;        int more = r;//大于区一开始就包括r        while (l &lt; more) {            if (s1[l] &lt; s1[r]) {                swap(s1, ++less, l++);            } else if (s1[l] &gt; s1[r]) {                swap(s1, --more, l);            } else {                l++;            }        }        //r位置划分好了more都是大于r所以要交换        swap(s1, more, r);        return new int[] { less + 1, more };//等于区域或者小于区域或大于区域不存在都是对的    }    public static void swap(int[] arr, int l, int r) {        int temp = arr[l];        arr[l] = arr[r];        arr[r] = temp;    }}</code></pre><ul><li>一般写法</li></ul><pre><code class="java">public void quick(int[]arr,int left,int rigth){    if(left&gt;rigth){        return;    }    int l = left;    int r = rigth;    int key = arr[left];//划分值    while(l &lt;= r){        while(arr[r] &gt;= key &amp;&amp; l &lt; r){//一定要开始从右边开始判断            r--;        }        if(l&lt;r){            arr[l] = arr[r];        }        while(arr[l] &lt;= key &amp;&amp; l &lt; r){            l++;        }        if(l &lt; r){            arr[r] = arr[l];        }        arr[l] = key;    }    quick(arr,l-1,left);//左边递归    quick(l+1,rigth);//右边递归}</code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><strong>基本思想</strong></p><ul><li>从序列第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，设为待插入元素，在已经排序的元素序列中从后向前扫描，如果该元素（已排序）大于待插入元素，将该元素移到下一位置。</li><li>重复步骤2，直到找到已排序的元素小于或者等于待排序元素的位置，插入元素。</li><li>重复2，3步骤，完成排序。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210111140358.png" alt="img"></p><pre><code class="java">public void InsertionSort(int []arr){    if(arr==null||arr.length&lt;2){        return;    }    //假设第一个数就有序所以从第二个元素开始遍历    for(int i = 1;i&lt;arr.length;i++){        //和前一个位置上的数比较如果大就交换，一直比到大为止        for(int j = i-1;j&gt;=0 &amp;&amp; arr[j] &gt; arr[j-1];j--){            swap(arr,j,j-1);    }}//不使用额为变量的交换public static void swap(int[] arr, int i, int j) {        arr[i] = arr[i] ^ arr[j];        arr[j] = arr[i] ^ arr[j];        arr[i] = arr[i] ^ arr[j];}    </code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><strong>基本思想</strong></p><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p><p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210111171005.png" alt="img"></p><pre><code class="java">//分    public static void mergeSort(int[] arr, int l, int r) {        if (l == r) {            return;        }        int mid = (l + r) / 2;        mergeSort(arr, l, mid);        mergeSort(arr, mid + 1, r);        merge(arr, l, mid, r);    }//治    public static void merge(int[] arr, int l, int mid, int r) {        int[] help = new int[r - l + 1];// 辅助数组        int s = 0;// 辅助数组第一个个下标        int i = l;// 左边第一个下标        int j = mid + 1;// 右边第一个下标        while (i &lt;= mid &amp;&amp; j &lt;= r) {// 循环结束必有一个越界            help[s++] = arr[i] &lt; arr[j] ? arr[i++] : arr[j++];        }        while (i &lt;= mid) {// i越界就拷贝i后面的数            help[s++] = arr[i++];        }        while (j &lt;= r) {// j越界就拷贝j后面的数            help[s++] = arr[j++];        }        // 辅助数组排好的数拷贝回原来数组        for (int z = 0; z &lt; help.length; z++) {            arr[l + z] = help[z];        }    }</code></pre><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><strong>介绍</strong></p><ul><li>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用。</li><li>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法。</li><li>基数排序(Radix Sort)是桶排序的扩展。</li><li>基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较</li><li>桶排序的对象不是能是对象类型</li><li>桶排序是很典型的空间换时间的算法</li></ul><p><strong>思想</strong></p><p>首先定义10个<img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210111191826.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210111191819.png" alt="img"><strong>“桶”</strong>，下标为0~9；然后遍历数组，按照元素的<strong>“个位”</strong>数值，依次放入对应下标的桶中，放完所有元素后，从第0个桶开始遍历，依次取出桶中元素按顺序放入原始数组中；同理，之后再遍历数组，按照元素的<strong>“十位”</strong>数值，做上一步相同的操作；以此类推，直到按照数组中最大元素的最高位操作完为止。<img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210111191808.png" alt="img"></p><pre><code class="java">public void radixSort(int []arr){    //找到最大数获得最大数的位数    int max = arr[0];    for(int i = 0;i&lt;arr.length;i++){        if(arr[i]&gt;max){            max = arr[i];        }    }    int maxlength = (max+"").length;//获得位数值    int [][]bucket = new int[10][arr.length];//创建10个桶    int []sum = new int[10];//arr[0]放1号桶的个数以此类推    //最大数是几位就要遍历几次    for(int i=0,n=1;i&lt; maxlength;i++,n*=10){        for(int j = 0;j&lt;arr.length;j++){            int dig = arr[i]/n % 10;//获得n位上的数            bucket[dig][sum[dig]]=arr[j];            sum[dig]++;        }    }    //把桶中的数遍历到原来数组中    int index = 0;//用于遍历    for(int k = 0;k&lt;sum.length;k++){        if(sum[k]!=0){            for(int l = 0;l&lt;sum[k];l++){                arr[index++] = bucket[k][l];            }        }        sum[k] = 0;    }}</code></pre><h2 id="六、查找"><a href="#六、查找" class="headerlink" title="六、查找"></a>六、查找</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><strong>介绍</strong></p><p>二分查找（Binary Search）技术，又称为折半查找。它的前提是线性表中的记录必须是<strong>关键码有序</strong>（通常从小到大有序），线性表必须采用顺序存储。它的查找过程是：在有序表中，取<strong>中间记录</strong>作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止</p><pre><code class="java">//递归实现public int binary(int []arr,int left,int right,int val){    if(left &gt; rigth){        return -1;    }    mid = (left+right)/2;    if(val &gt; arr[mid]){        binary(arr,mid+1,right,val);    }    else if(val&lt;arr[mid]){        binary(arr,left,mid-1,val);    }    else{        return mid;    }} //非递归实现public int Binary(int []arr,int left,int rigth,int val){    while(left&lt;=rigth){        mid = (left + rigth)/2;        if(arr[mid]&lt;val){            left = mid+1;        }        else if(arr[mid]&gt;val){            rigth = mid-1;        }        else if(arr[mid]==val){            return mid;        }    }    return -1;}</code></pre><h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h3><p><strong>介绍</strong></p><p>插值查找算法类似于二分查找，也需要记录是<strong>有序</strong>的，不同的是插值查找每次从<strong>自适应</strong>mid处开始查找。<br>将二分查找求中间记录的mid 索引公式改成：</p><p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210118174635.png" alt="img"></p><p>key：要查找的值；low：第一个记录在数组中的索引值；high：最后一个记录在数组中的索引值</p><p><strong>(key-a[low]) / (a[high]-a[low])就是查找值在这个均匀分布的有序序列中的大致位置的系数</strong></p><p>对应的代码公式为：</p><pre><code>int mid = left + (right - left) *(value - arr[left]) / (arr[right] - arr[left]);</code></pre><pre><code class="java">public int insertValueSearch(int []arr,int left,int rigth,int val){    if(left &gt;rigth||val&lt;arr[0]||val&gt;arr.length-1){        return -1;    }    int mid = left + (right - left) *(value - arr[left]) / (arr[right] - arr[left]);    if(val &gt; arr[mid]){        binary(arr,mid+1,right,val);    }    else if(val&lt;arr[mid]){        binary(arr,left,mid-1,val);    }    else{        return mid;    }}</code></pre><p><strong>注意事项</strong></p><ul><li>对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找， 速度较快</li><li>关键字分布不均匀的情况下，该方法不一定比折半查找要好</li></ul><h2 id="七、散列表（哈希表）"><a href="#七、散列表（哈希表）" class="headerlink" title="七、散列表（哈希表）"></a>七、散列表（哈希表）</h2><p><strong>介绍</strong></p><p>散列表(Hash table，也叫哈希表)，是根据关键码值(Key value)而直接进行访问的<strong>数据结构</strong>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。<code>存储位置 = f(key)</code>，这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>散列技术既是一种存储方法，也是一种查找方法。散列技术最适合的求解问题是查找与给定值相等的记录。</p><ul><li>哈希表是一种将<strong>数组与链表相结合</strong>的数据结构</li></ul><p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210118174610.png" alt="img"></p><pre><code class="java">class student{    int id;    String name;    student next;    public studen(int id,String name){        this.id = id;        this.name = name;    }     @Override   public String toString() {      return "Student{" +            "id=" + id +            ", name='" + name + '\'' +            '}';   }}class LinkedList(){    private student head;    public void add(student student){        if(head == null){            head = student;            return;        }        student cur = head;        while(true){            if(cur.next ==null){                break;            }            cur = cur.next;        }        cur.next = student;    }    public void list(){        if(head == null){            System.out.println("链表为空");            return;        }        student cur = head;        while(cur != null){            System.out.printf("---&gt; id=%d name=%s\t", cur.id, cur.name);            cur = cur.next;        }        System.out.println();    }    //通过ID查找学生信息    public student searchStudentId(int id){        if(head==null){            student cur = head;            while(true){                if(head.id = id){                    break;                }                if(head.next ==null){                    cur = null;                    break;                }                cur = cur.next;            }            return cur;        }    }class HashTab {        private int size;        private LinkedList[] s;        public HashTab(int size){            this.size = size;            s = new LinkedList(size);            for(int i = 0;i&lt;size;i++){                  //对每个链表进行初始化操作                 s[i] = new studentList();            }        }        public void list(){            for(int i = 0;i&lt;size;i++){                s[i].list();            }        }        public void add(student s){            int no = getHash(s.id);            s[no].add(s);        }        //获取散列值        public int getHash(int id){            return id % size;        }        public void findStuById(int id){            int no = getHash(id);            s[no].searchStudentId(id);        }     }   }public class Demo5 {   public static void main(String[] args) {      //创建学生      Student student1 = new Student(1, "Nyima");      Student student2 = new Student(2, "Lulu");      Student student6 = new Student(6, "WenWen");      HashTab hashTab = new HashTab(5);      hashTab.add(student1);      hashTab.add(student2);      hashTab.add(student6);      hashTab.traverse();      //通过id查找学生信息      hashTab.findStuById(6);   }}</code></pre><h2 id="八、树结构"><a href="#八、树结构" class="headerlink" title="八、树结构"></a>八、树结构</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>为什么需要树结构</strong></p><ul><li>数组的查找效率高，但是插入效率低。</li><li>链表的插入效率高，查找效率低。</li></ul><p>需要一种数据结构来平衡查找与插入效率，使得查找速度和插入速度都能得到提升，因此有了树这种数据结构。</p><p><strong>二叉树的基本概念</strong></p><p>每个节点最多只能有两个节点</p><p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210118201035.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210118201015.png" alt="img"></p><p><strong>满二叉树</strong></p><p>如果该二叉树的所有<strong>叶子节点</strong>都在<strong>最后一层</strong>，并且结点总数= <strong>2n -1</strong> , n为层数，则我们称为满二叉树。<img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210118201147.png" alt="img"></p><p><strong>完全二叉树</strong></p><p>如果该二叉树的所有<strong>叶子节点</strong>都在<strong>最后一层</strong>或者<strong>倒数第二层</strong>，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树<img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210118201343.png" alt="img"></p><p><strong>二叉树的遍历</strong></p><p>前序遍历</p><p><strong>先遍历父节点</strong>，再遍历左子节点，最后遍历右子节点</p><p>中序遍历</p><p>先遍历左子节点，<strong>再遍历父节点</strong>，最后遍历右子节点</p><p>后序遍历</p><p>先遍历左子节点，再遍历右子节点，最后<strong>遍历父节点</strong></p><p><strong>可以看出，前中后的区别在于父节点遍历的时机</strong></p><p><strong>二叉树的递归序</strong></p><p>125552666213331</p><p>每个节点都会回到自己三次</p><p>前序就是第一次出现的时候打印</p><p>中序就是第二次出现打印</p><p>后序就是第三次出现打印</p><p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210118201545.png" alt="img"></p><p>前序结果：1 2  5 6 3</p><p>中序结果：5 2 6 1 3</p><p>后序结果：5 6 2 3</p><p><strong>递归版</strong></p><pre><code class="java">public class binaryTreeDemo {    public static void main(String[] args) {        // 创建二叉树        BinaryTree binaryTree = new BinaryTree();        // 手动创建节点，并放入二叉树中        sutNode stu1 = new sutNode(1, "A");        sutNode stu2 = new sutNode(2, "B");        sutNode stu3 = new sutNode(3, "C");        sutNode stu4 = new sutNode(4, "D");        stu1.setLeft(stu2);        stu1.setRight(stu3);        stu3.setRight(stu4);        binaryTree.setRoot(stu1);        // 遍历二叉树        binaryTree.preOrder();        System.out.println();        binaryTree.infixOrder();        System.out.println();        binaryTree.postOrder();    }}//二叉树class BinaryTree {    // 根节点    private sutNode root;    public void setRoot(sutNode root) {        this.root = root;    }    public void preOrder() {        if (this.root != null) {            this.root.preOrder();        } else {            System.out.println("二叉树为空，无法遍历");        }    }    public void infixOrder() {        if (this.root != null) {            this.root.infixOrder();        } else {            System.out.println("二叉树为空，无法遍历");        }    }    public void postOrder() {        if (this.root != null) {            this.root.postOrder();        } else {            System.out.println("二叉树为空，无法遍历");        }    }}//二叉树的节点class sutNode {    private int id;    private String name;    private sutNode left;    private sutNode right;    public sutNode(int id, String name) {        this.id = id;        this.name = name;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public sutNode getLeft() {        return left;    }    public void setLeft(sutNode left) {        this.left = left;    }    public sutNode getRight() {        return right;    }    public void setRight(sutNode right) {        this.right = right;    }    @Override    public String toString() {        return "sutNode [id=" + id + ", name=" + name + "]";    }    // 前序遍历    public void preOrder() {        System.out.println(this);        if (this.left != null) {            this.left.preOrder();        }        if (this.right != null) {            this.right.preOrder();        }    }    // 中序    public void infixOrder() {        if (this.left != null) {            this.left.infixOrder();        }        System.out.println(this);        if (this.right != null) {            this.right.infixOrder();        }    }    // 后序    public void postOrder() {        if (this.left != null) {            this.left.postOrder();        }        if (this.right != null) {            this.right.postOrder();        }        System.out.println(this);    }}</code></pre><pre><code class="java">//前序sutNode [id=1, name=A]sutNode [id=2, name=B]sutNode [id=3, name=C]sutNode [id=4, name=D]//中序sutNode [id=2, name=B]sutNode [id=1, name=A]sutNode [id=3, name=C]sutNode [id=4, name=D]//后序sutNode [id=2, name=B]sutNode [id=4, name=D]sutNode [id=3, name=C]sutNode [id=1, name=A]</code></pre><p><strong>非递归版</strong></p><pre><code class="java">class tree{    int val;    tree left;    tree right;}//先序遍历//头节点先压入栈中，打印并弹出//然后先右再左的压，弹到栈空 pulic void preOrder(tree head){        if(head != null){            Stack&lt;tree&gt; s = new Stack&lt;tree&gt;();            s.add(head);            while(!s.isEmply()){                head = s.pop();                System.out.println(head.val);                if(head.right!= null){                    s.add(head.right);                }if(head.left!=null){                    s.add(head.left);                                }            }        }    }//思路先序遍历是头左右，先压左在压右就可以实现头右左用两个栈就可以实现左右头了//后序遍历public void postOrder(tree head){    if(head != null){        Stack&lt;tree&gt; s = new Stack&lt;tree&gt;();        Stack&lt;tree&gt; s1 = new Stack&lt;tree&gt;();        s.add(head){            while(!s.isEmply()){                head = s.pop();                s2.add(head);                if(head.left!=null){                s.add(head.left);                }if(head.right!= null){                s.add(head.right);                    }             }while(s1.isEmply()){                 System.out.println(s1.pop().val);            }    }}//中序遍历 1、每课子树的左边界都压入栈，依次弹出并打印     //让弹出节点返回第一步public void infixOrder(tree head){     if(head != null){         Stack&lt;tree&gt; s = new Stack&lt;tree&gt;();         while(!s.isEmply()||head!=null){            if(head!=null){                s.push(head);                head = head.left;            }else{                s.pop();                System.out.println(head.val);                head = head.right;            }        }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏数组</title>
      <link href="2021/01/02/xi-shu-shu-zu/"/>
      <url>2021/01/02/xi-shu-shu-zu/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210102173643.png" alt="2LEB$9[5XB}X5PR}_@9]NPO"></p><p>数组中存了很多没定义的值我们就可以把它转换成稀疏数组</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>当一个数组中的大部分元素是0是或者是一个相同的数值时，我们可以用稀疏数组来保存原来数组</p><p>稀疏数组的处理方法是：</p><p>1.记录数组<strong>一共几行几列，有多少个有效值</strong></p><p>2.把具不同值元素的行号和列号及值保持到一个小规模的数组中，从而<strong>减小规模</strong></p><p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210102174449.png"></p><h2 id="思路及其实现"><a href="#思路及其实现" class="headerlink" title="思路及其实现"></a>思路及其实现</h2><p><img src="https://cdn.jsdelivr.net/gh/javaqiandsgfkl/tuchuagn/images/20210102174555.png" alt="image-20200723150712766"></p><p><strong>二维数组转稀疏数组的思路：</strong></p><p>1.遍历原始的二维数组，得到有效数据的个数sum<br>2.根据sum就可以创建稀疏数组sparseArr = int[sum+1] [3]<br>3.将二维数组的有效数据存入到稀疏数组中</p><p><strong>稀疏数组转原始的二维数组的思路：</strong></p><p>1.先读取稀疏数组的第一行，根据第一行数据，创建原始的二维数组，比如上面的 chessArr2 = int[11] [11]<br>2.再读取稀疏数组后几行的数据，并赋给原始的二维数组即可</p><p>代码实现：</p><pre><code class="java">public class sparse {    //创建二维数组11*11的数组    //0表示没棋子1表示白棋2表示黑棋    public static void main(String []args) {        int arr1[][] = new int[11][11];        arr1[2][3] = 1;        arr1[4][5] = 2;        for (int[] a:arr1) {            for(int val: a) {                System.out.printf("%d\t", val);            }            System.out.println();        }        //遍历获得有效数据        int sum = 0;//标记        for(int i = 0;i&lt;arr1.length;i++) {            for(int j = 0;j&lt;arr1.length;j++) {                if(arr1[i][j]!=0) {                    sum++;                }            }        }        int SparseArr[][] = new int [sum+1][3];        SparseArr[0][0] = 11;        SparseArr[0][1] = 11;        SparseArr[0][2] = sum;        //遍历数据添加数据        int cout = 0;//计入第几个非零的值        for(int i = 0;i&lt;arr1.length;i++) {            for(int j = 0;j&lt;arr1.length;j++) {                if(arr1[i][j]!=0) {                    cout++;                    //稀疏数组第一列是存有效数据的行号                    //第二列是存列好                    //第三列是值                    SparseArr[cout][0] = i;                    SparseArr[cout][1] = j;                    SparseArr[cout][2] = arr1[i][j];                }            }        }        // 输出稀疏数组的形式        System.out.println();        System.out.println("得到稀疏数组为~~~~");        for (int i = 0; i &lt; SparseArr.length; i++) {            System.out.printf("%d\t%d\t%d\t\n", SparseArr[i][0], SparseArr[i][1], SparseArr[i][2]);        }        System.out.println();                //稀疏数组恢复原来数组        int arr2[][] = new int[SparseArr[0][0]][SparseArr[0][1]];        for(int i = 1;i&lt;SparseArr.length;i++) {            arr2[SparseArr[i][0]][SparseArr[i][1]] =  SparseArr[i][2];        }        System.out.println();        System.out.println("恢复后的二维数组");        for (int[] row : arr2) {            for (int data : row) {                System.out.printf("%d\t", data);            }            System.out.println();        }    }}</code></pre><p>输出结果：</p><p>0    0    0    0    0    0    0    0    0    0    0<br>0    0    0    0    0    0    0    0    0    0    0<br>0    0    0    1    0    0    0    0    0    0    0<br>0    0    0    0    0    0    0    0    0    0    0<br>0    0    0    0    0    2    0    0    0    0    0<br>0    0    0    0    0    0    0    0    0    0    0<br>0    0    0    0    0    0    0    0    0    0    0<br>0    0    0    0    0    0    0    0    0    0    0<br>0    0    0    0    0    0    0    0    0    0    0<br>0    0    0    0    0    0    0    0    0    0    0<br>0    0    0    0    0    0    0    0    0    0    0    </p><p>得到稀疏数组为~~~~<br>11    11    2<br>2    3    1<br>4    5    2    </p><p>恢复后的二维数组<br>0    0    0    0    0    0    0    0    0    0    0<br>0    0    0    0    0    0    0    0    0    0    0<br>0    0    0    1    0    0    0    0    0    0    0<br>0    0    0    0    0    0    0    0    0    0    0<br>0    0    0    0    0    2    0    0    0    0    0<br>0    0    0    0    0    0    0    0    0    0    0<br>0    0    0    0    0    0    0    0    0    0    0<br>0    0    0    0    0    0    0    0    0    0    0<br>0    0    0    0    0    0    0    0    0    0    0<br>0    0    0    0    0    0    0    0    0    0    0<br>0    0    0    0    0    0    0    0    0    0    0    </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 稀疏数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github配置命令</title>
      <link href="2020/12/30/github-pei-zhi-ming-ling/"/>
      <url>2020/12/30/github-pei-zhi-ming-ling/</url>
      
        <content type="html"><![CDATA[<h3 id="博客的基本操作"><a href="#博客的基本操作" class="headerlink" title="博客的基本操作"></a>博客的基本操作</h3><p>1.在博客目录下hexo new  “文件名”</p><p>2.npm install –save hexo-deployer-git          本地和github连接</p><p>3.每次修改hexo clean 清理  hexo g  解析  hexo d 部署到github</p><p>4._config.yml文件里最后面增加</p><p>​    type: ‘git’</p><p>​    repo: 自己的仓库地址</p><p>​    branch: master</p><p>5.更新主题在themes下git clone 主题的地址，然后把在_config.yml文件里吧themes 后面改成主题文件名</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre><code>---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---</code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre><code>---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre><h3 id="配置个性化域名"><a href="#配置个性化域名" class="headerlink" title="配置个性化域名"></a>配置个性化域名</h3><p>一顿操作下来，打开我们的博客还是：<a href="http://www.xxx.github.io/">www.xxx.github.io</a>，是不是很没有牌面？我们可以考虑购买一个专属域名，以后打开博客就是这样：<a href="http://www.xxx.com/">www.xxx.com</a> 。</p><p><a href="https://www.aliyun.com/">阿里云</a>和<a href="https://cloud.tencent.com/">腾讯云</a>都可以，我的是腾讯云，购买域名后首先需要添加解析：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/24.png" alt="img"></p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/25.png" alt="img"></p><p><strong>方法一：</strong>点击添加记录，需要添加两个记录，两个记录类型都是 CNAME ，第一个主机记录为 @ ，第二个主机记录为 www，记录值都是填你自己的博客地址（比如我的是：muyiio.github.io），保存之后域名解析就完成了！</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/27.png" alt="img"></p><p><strong>方法二：</strong>两个记录类型为 A ，第一个主机记录为 @ ，第二个主机记录为 www，记录值都为博客的 IP 地址，IP 地址可以 cmd 中输入 ping 你的博客地址 获得（比如我的：ping muyiio.github.io），保存之后域名解析就完成了！</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/26.png" alt="img"></p><p><strong>不管在哪个平台购买域名，操作都大同小异，这里说明两点</strong>：</p><p>然后打开你的github博客项目，点击settings，拉到下面Custom domain处，填上你自己的域名，保存就可以了</p><p>现在我们的项目根目录应该会出现一个名为CNAME的文件了。如果没有的话，打开你本地博客/source目录，我的是C:\Blog\Hexo\source，新建CNAME文件，（注意不要加.txt，没有任何后缀名！）。然后在里面写上你的域名，保存。最后运行hexo g、hexo d上传到github。</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/29.png" alt="img"></p><p>现在就可以通过我们的个性化域名：<a href="http://www.xxx.com、xxx.com/">www.xxx.com、xxx.com</a>访问自己的博客了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
